'use strict';
const jwtDecode = require('jwt-decode');
const passportUtils = require('../passport/utils');
const xssec = require('@sap/xssec');
const pathUtil = require('../utils/path-util');
const headerUtils = require('../utils/header-util');
const logger = require('../utils/logger');
const vcapUtils = require('../utils/vcap-utils');

module.exports = function (req, res, next) {
  let auth = req.headers && req.headers['x-approuter-authorization'];
  let tokenDecoded;

  if (!auth) {
    return next();
  }
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.debug('Incoming request contains x-approuter-authorization header');

  if (req.routerConfig && pathUtil.isPublicPath(req)) {
    tracer.debug('Request to public route with source %s contains x-approuter-authorization header ', req.internalUrl.route.source);
  }

  try {
    tokenDecoded = jwtDecode(auth);
  } catch (err) {
    let error  = new Error('Failed to decode x-approuter-authorization token ' + err);
    error.status = 400;
    return next(error);
  }
  const authArr = auth.split(' ');
  const type = authArr[0];
  const tokenValue = authArr[1];
  let service = getCredentialsAndSecurityType(tokenDecoded);
  if (!service.credentials) {
    return next('No Security service instance bound for service type ' + service.type);
  }
  if (type.toLowerCase() !== 'bearer') {
    writeAuditLog(req, tokenValue, 'x-approuter-authorization header is not a Bearer token', 400, tokenDecoded, service.credentials, next);
    return next();
  }
  const config = {
    credentials: service.credentials,
    correlationId: headerUtils.getCorrelationId(req)
  };
  xssec.createSecurityContext(tokenValue, config, service.type, async function (err) {
    if (err) {
      writeAuditLog(req, tokenValue, `${err.message} - Token validation failed for request url ${req.url}`, 401, tokenDecoded, service.credentials, next);
      return next();
    } else {
      const externalSessionStore = req && req.app && req.app.get('externalSessionStore');
      let externalSession = null;
      if (externalSessionStore){
        externalSession =  await externalSessionStore.getExternalSession(tokenDecoded.jti, req);
      }

      if (externalSession) {
        req.session = externalSession;
      } else {
        const tokenContext = {
          accessToken: tokenValue,
          expiresIn: Date.now() + 600000,
          scope: tokenDecoded.scope
        };
        req.session = {
          externalSessionId: externalSessionStore && tokenDecoded.jti,
          externalSessionExpiration: externalSessionStore && tokenDecoded.exp,
          jwtRefreshStarted: true,
          user: passportUtils.getUserProperties(tokenContext),
          req: req,
          reload: function (cb) {
            cb();
          },
          save: function () {
          },
          touch: function () {
          }
        };
        if (externalSessionStore){
          await externalSessionStore.updateExternalSession(req.session);
        }
      }
      tracer.info('Session created successfully');
      return next();
    }
  });
};

function writeAuditLog(req, token, errorMessage, errorStatus, tokenDecoded, credentials, next) {
  let auditlogCredentials;
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.error && tracer.error(errorMessage);
  auditlogCredentials = vcapUtils.getServiceCredentials({tag: 'auditlog'});

  let IP = (auditlogCredentials) ? req.headers['x-forwarded-host'] : '******';
  const authorization = (auditlogCredentials) ? token : '******';
  const sourceOfRoute = req.internalUrl ? req.internalUrl.route.source : req.url;
  const message = errorMessage + '- Source of route: ' + sourceOfRoute + ', IP: ' + IP + ', x-approuter-authorization: ' + authorization;

  const loggingData = {};
  loggingData.user = 'Service to Approuter request';
  loggingData.tenantid = getTenant(req, tokenDecoded, credentials);
  logger.writeToAuditLog(req, loggingData, message, function (err) {
    if (err) {
      req && req.logger && req.logger.error('Error occurred when writing to audit log. Error: %s', err.message);
    }
    let error = new Error(errorMessage);
    error.status = errorStatus;
    return next(error);
  });
}

function getTenant(req, tokenDecoded, credentials) {
  let tenant = credentials.identityzone;
  if (req.headers['x-subscriber-tenant']) {
    tenant = req.headers['x-subscriber-tenant'];
  } else {
    if (tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn) {
      tenant = tokenDecoded.ext_attr.zdn;
    } else if (tokenDecoded['iss']) {
      tenant = getIasTenant(tokenDecoded);
    }
  }
  return tenant;
}

function getIasTenant(tokenDecoded) {
  let temp = tokenDecoded['iss'].split('.')[0].split('/');
  return temp[temp.length - 1];
}

function getCredentialsAndSecurityType(tokenDecoded) {
  let service = {};
  if (tokenDecoded && tokenDecoded.ext_attr) {
    service.credentials = vcapUtils.getServiceCredentials({tag: 'xsuaa'});
    service.type = 'XSUAA';
  } else {
    service.credentials = vcapUtils.getServiceCredentials({label: 'identity'});
    service.type = 'IAS';
  }
  return service;
}
