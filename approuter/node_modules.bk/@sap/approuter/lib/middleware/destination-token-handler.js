'use strict';
const destinationUtils = require('../../lib/utils/destination-utils');
const tokenUtils = require('../../lib/utils/token-utils');
const jwtDecode = require('jwt-decode');
const expiresAt = require('../passport/utils').getExpiresAt;
const validators = require('../configuration/validators');

const self = module.exports = {

  retrieveDestination: function (options, cb) {
    self.replaceUserToken(options, function (err, userExchangeToken) {
      if (err) {
        return cb(err);
      }
      let tokenDecoded;
      let userExchangeTokenExpiresAt;
      let destinationName = options.destinationName;
      let accessToken = userExchangeToken && userExchangeToken.access_token ? userExchangeToken.access_token : userExchangeToken;
      destinationUtils.findDestination(destinationName, accessToken, options, function (err, destinationLookUpResult) {
        if (err) {
          return cb(err);
        }
        try {
          if (!destinationLookUpResult || !destinationLookUpResult.destinationConfiguration) {
            return cb('Cannot get destination configuration for destination ' + destinationName);
          }
          if (destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].hasOwnProperty('error')) {
            return cb(destinationLookUpResult.authTokens[0].error);
          }
          if (destinationLookUpResult.authTokens) {
            let authTokenExpiresIn = destinationLookUpResult.authTokens[0].expires_in;
            destinationLookUpResult.authTokens[0].expireDate = destinationLookUpResult.authTokens[0].expires_in ? expiresAt(authTokenExpiresIn).getTime() : 0;
          }
          let result = {};
          if (userExchangeToken) {
            tokenDecoded = jwtDecode(userExchangeToken);
            userExchangeTokenExpiresAt = expiresAt(tokenDecoded.exp - tokenDecoded.iat).getTime();
            result.userExchangeToken = {
              token: userExchangeToken,
              expireDate: userExchangeTokenExpiresAt,
              destinationKey: options.destinationKey
            };
          }
          let destinationsConfigurations = [destinationLookUpResult.destinationConfiguration];
          destinationUtils.normalizeDestinationProperties(destinationsConfigurations);
          const normalizedCertificateProperties = destinationUtils.isDestinationCertificatesFlow(destinationsConfigurations[0])
            && destinationUtils.normalizeCertificateProperties(destinationLookUpResult.certificates);
          validators.validateDestinations(destinationsConfigurations);
          destinationUtils.adjustDestinationProperties(destinationsConfigurations);
          result.destination = destinationsConfigurations[0];
          result.expireDate = destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].expireDate;
          if (options.dynamicDestination && !result.destination.dynamicDestination) {
            return cb('Destination ' + destinationName + ' is not defined as a dynamic destination in destination service, configure additional property HTML5.DynamicDestination true');
          }
          result.authToken = destinationLookUpResult.authTokens ? destinationLookUpResult.authTokens[0] : null;
          result.destination.certificates = normalizedCertificateProperties && destinationUtils.getDestinationCertificate(destinationsConfigurations[0], normalizedCertificateProperties);
          return cb(null, result);
        } catch (error) {
          return cb(error);
        }
      });
    });
  },

  isDestinationServiceFlow: function (internalUrl) {
    if (!internalUrl || !internalUrl.route || !internalUrl.route.destination || !internalUrl.destination ||
      internalUrl.destination.url !== 'DESTINATION_URL_PLACEHOLDER') {
      return false;
    }
    return true;
  },

  replaceUserToken: function (options, cb) {
    let session = options.session;
    if (!session || !session.user) {
      return cb(null);
    }
    shouldRequestUserExchangeToken(session, options.destinationKey, function (err, askForToken) {
      if (err) {
        return cb(err);
      }
      if (!askForToken) {
        let userExchangeToken = options.destinationKey && session.user.destinationKey && session.user.destinationKey[options.destinationKey]
          ? session.user.destinationKey[options.destinationKey].destinationUserExchangeToken.token : session.user.destinationUserExchangeToken.token;
        return cb(null, userExchangeToken);
      }
      let externalServiceCredentials;
      if (options.destinationKey && options.app && options.app.services[options.destinationKey]) {
        externalServiceCredentials = options.app.services[options.destinationKey].credentials;
        externalServiceCredentials.url = externalServiceCredentials.tokenServiceURL;
        externalServiceCredentials.clientid = externalServiceCredentials.clientId;
        externalServiceCredentials.clientsecret = externalServiceCredentials.clientSecret;
      } else {
        externalServiceCredentials = destinationUtils.getDestinationServiceCredentials();
      }
      if (!options.session.user.token) {
        return cb(`Missing token for session user. correlationId: ${options.correlationId}`);
      }
      let jwt = options.jwt;
      if (!jwt) {
        jwt = options.session.user.token.accessToken;
      }
      return tokenUtils.exchangeToken(jwt, options.correlationId, externalServiceCredentials, cb);
    });
  },
  addDestinationHeaders: function (req) {
    if (req.headers && req.internalUrl && req.internalUrl.destination) {
      const escapeHeaders = Object.keys(req.headers);
      for (const destinationKey in req.internalUrl.destination) {
        if (destinationKey.startsWith('uRL.headers')) {
          const headerKey = destinationKey.split('.')[2];
          if (headerKey && !escapeHeaders.includes(headerKey)) {
            req.headers[headerKey] = req.internalUrl.destination[destinationKey];
          }
        }
      }
    }
    return req;
  }
};

function shouldRequestUserExchangeToken(session, destinationKey, cb) {
  let destinationTokensCache = destinationKey && session.user.destinationKey && session.user.destinationKey[destinationKey]
    ? session.user.destinationKey[destinationKey].destinationUserExchangeToken : session.user.destinationUserExchangeToken;

  // check the expiration of destinationUserExchangeToken
  if (!destinationTokensCache || (destinationKey && (destinationKey !== destinationTokensCache.destinationKey)) || (!destinationTokensCache.token || destinationTokensCache.expireDate < Date.now())) {
    return cb(null, true);
  }
  return cb(null, false);
}
