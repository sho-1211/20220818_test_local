/* eslint-disable camelcase */
'use strict';
var request = require('./request-utils');
var tokenUtils = require('./token-utils');
var headerUtils = require('./header-util');
var dynamicRoutingUtils = require('./dynamic-routing-utils');

module.exports.logRequestError = function(req, message) {
  if (req && req.logger && process.env.SAAS_APPROUTER) {
    req.logger.error(message);
  }
};

module.exports.logRequestInfo = function(req, message) {
  if (req && req.logger && process.env.SAAS_APPROUTER) {
    req.logger.info(message);
  }
};

module.exports.logRequestSetTenant = function(req, tenant) {
  if (req && req.logger) {
    req.logger.setTenantId(tenant);
    if (!req.logger.getCorrelationId()) {
      req.logger.setCorrelationId(headerUtils.getCorrelationId(req));
    }
  }
};

module.exports.getApplicationLogs = function(req, res) {
  return new Promise((resolve, reject) => {
    tokenUtils.getAuthenticationJar(function(err, jar) {
      if (err) {
        return reject(err);
      }
      module.exports.getElasticSearchRequestOptions(req,jar,(err, requestOptions) => {
        if (err) {
          return reject(err);
        }
        module.exports.callKibanaServer(requestOptions, function(err, respBody) {
          if (err) {
            return reject(err);
          }
          const logs = [];
          if (respBody.responses) {
            respBody.responses.forEach((response) => {
              response.hits.hits.forEach((hit) => {
                if (hit._source.msg && hit._source.msg !== '-') {
                  logs.push({
                    message: hit._source.msg,
                    correlationId: hit._source.correlation_id,
                    timestamp: hit._source['@timestamp'],
                    level: hit._source.level
                  });
                }
              });
            });
          } else {
            respBody.rawResponse.hits.hits.forEach((hit) => {
              if (hit._source.msg && hit._source.msg !== '-') {
                logs.push({
                  message: hit._source.msg,
                  correlationId: hit._source.correlation_id,
                  timestamp: hit._source['@timestamp'],
                  level: hit._source.level
                });
              }
            });
          }
          res.setHeader('Content-Type', 'application/json');
          res.end(JSON.stringify(logs));
        });
      });
    });
  });
};

module.exports.callKibanaServer = function(requestOptions, cb) {
  request.post(requestOptions, function(err, response, body) {
    if (err || response.statusCode !== 200) {
      const error = new Error('Failed to execute query ' + requestOptions.body + ' response status ' +
          response.statusCode + ' ' + (body ? body : '') + err);
      return cb(error);
    }
    const respBody = JSON.parse(response.body);
    cb(null, respBody);
  });
};

function kibanaQuery(req, isNew) {
  const timeRange = 1440; // One day in minutes
  const timestampNow = new Date();
  const end = timestampNow.getTime();
  const start = end - timeRange * 60 * 1000;
  const timestampYesterday = new Date(timestampNow);
  timestampYesterday.setHours(timestampYesterday.getHours() - 24);
  if (req.headers['x-application-key']){
    let applicationKey = dynamicRoutingUtils.getApplicationKey({url: '/' + req.headers['x-application-key']});
    let tenantKey = applicationKey && applicationKey.appDestinationId ? req.tenant + '-' + applicationKey.appDestinationId + '.' + applicationKey.appPrefix + '.' + applicationKey.appNameWithoutPrefix :
      req.tenant + '-' + applicationKey.appPrefix + '.' + applicationKey.appNameWithoutPrefix;
    return isNew ? kibanaDayQueryNew(timestampNow, start, end, tenantKey) : kibanaDayQuery(timestampNow, start, end, tenantKey);
  } else {
    return isNew ? kibanaDayQueryNew(timestampNow, start, end, req.tenant) : kibanaDayQuery(timestampNow, start, end, req.tenant);
  }
}

module.exports.getElasticSearchRequestOptions = function(req,jar,cb){
  let logger = req.logger;
  let requestOptions = {
    url: process.env.LOGS_URL + '/api/status',
    jar: jar,
    headers: {
      'kbn-xsrf': 'true',
      'Content-Type': 'application/json'
    }
  };
  // Get Kibana server version
  request.get(requestOptions, function(err, response, apiStatusBody) {
    if (err || response.statusCode !== 200) {
      const error = new Error('Failed to get Kibana api status ' + ' response status ' +
          response.statusCode + (err || ''));
      return cb(error);
    }
    let jsonBody = null;
    try {
      jsonBody = JSON.parse(apiStatusBody);
    } catch (e) {
      return cb(new Error('Failed to parse get api status response ' + e));
    }
    logger && logger.info('Elastic search version is: ' + jsonBody.version.number);

    if (jsonBody.version.number === '7.4.2')
    {
      requestOptions.url = process.env.LOGS_URL + '/elasticsearch/_msearch';
      requestOptions.headers['Content-Type'] = 'application/x-ndjson';
      requestOptions.body = kibanaQuery(req);
    } else { // Newer versions
      requestOptions.url =  process.env.LOGS_URL + '/internal/search/es';
      requestOptions.body = kibanaQuery(req, true);
    }
    cb(null,requestOptions);
  });
};

function kibanaDayQuery(timestampReferenceDay, startTime, endTime, tenant) {
  const todayString = timestampReferenceDay.toISOString().substring(0, 10);
  const kibanaQuery0 = {
    'index': ['logstash-2016.07.01-es5'],
    'ignore_unavailable': true
  };
  kibanaQuery0.index = 'logstash-' + todayString.replace(/-/g, '.');

  const kibanaQuery1 = { // AppELK template
    'size': 10000,
    '_source': ['msg', '@timestamp', 'level', 'correlation_id'],
    'query': {
      'bool': {
        'must': [{
          'range': {
            '@timestamp': {
              'format': 'epoch_millis',
              'gte': startTime,
              'lte': endTime
            }
          }
        }, {
          'match': {
            'tenant_id': tenant
          }
        }, {
          'match': {
            'level': 'ERROR'
          }
        }]
      }
    }
  };
  return JSON.stringify(kibanaQuery0) + '\n' + JSON.stringify(kibanaQuery1) + '\n';
}

function kibanaDayQueryNew(timestampReferenceDay, startTime, endTime, tenant) {
  const query = {
    'params': {
      'index': 'logstash-*',
      'body': {
        'size': 10000,
        '_source': ['msg', '@timestamp', 'level', 'correlation_id'],
        'query': {
          'bool': {
            'must': [{
              'range': {
                '@timestamp': {
                  'format': 'epoch_millis',
                  'gte': startTime,
                  'lte': endTime
                }
              }
            }, {
              'match': {
                'tenant_id': tenant
              }
            }, {
              'match': {
                'level': 'ERROR'
              }
            }]
          }
        }
      }
    }
  };
  return JSON.stringify(query);
}